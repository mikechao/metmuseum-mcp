<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Met Explorer</title>
    <style>
      :root {
        --surface: var(--color-background-primary, #f8f6f3);
        --panel: var(--color-background-secondary, #ffffff);
        --text: var(--color-text-primary, #1f1a17);
        --muted: var(--color-text-secondary, #6c625c);
        --line: var(--color-border-primary, #dfd5cd);
        --accent: #9d1b2f;
        --accent-soft: #f8e8ea;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: var(--surface);
        color: var(--text);
        font-family: var(--font-sans, 'Avenir Next', 'Segoe UI', sans-serif);
      }

      * {
        box-sizing: border-box;
      }

      .app {
        display: grid;
        grid-template-rows: auto auto 1fr;
        gap: 12px;
        padding: 12px;
      }

      .controls {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
      }

      .controls-grid {
        display: grid;
        grid-template-columns: 1.5fr 1fr auto;
        gap: 8px;
      }

      .flags {
        display: flex;
        gap: 14px;
        align-items: center;
        margin-top: 8px;
        color: var(--muted);
        font-size: 13px;
      }

      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 4px;
      }

      input[type='text'],
      select,
      button {
        width: 100%;
        border-radius: 8px;
        border: 1px solid var(--line);
        min-height: 36px;
        padding: 0 10px;
        font: inherit;
        color: inherit;
        background: #fff;
      }

      button {
        background: var(--accent);
        color: #fff;
        border-color: var(--accent);
        font-weight: 600;
        cursor: pointer;
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }

      .status {
        font-size: 13px;
        color: var(--muted);
        min-height: 18px;
        padding: 0 2px;
      }

      .status.error {
        color: #b6242f;
      }

      .content {
        display: grid;
        grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
        gap: 12px;
        min-height: 420px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .panel-title {
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
        padding: 10px 12px;
        border-bottom: 1px solid var(--line);
      }

      .results-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
        gap: 10px;
        padding: 10px;
        overflow: auto;
        align-content: start;
      }

      .result-card {
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
        cursor: pointer;
        overflow: hidden;
      }

      .result-card img {
        width: 100%;
        height: 120px;
        object-fit: cover;
        display: block;
        background: #f1ece7;
      }

      .result-card .meta {
        padding: 8px;
      }

      .result-card .title {
        font-size: 13px;
        line-height: 1.3;
        font-weight: 600;
        margin-bottom: 4px;
      }

      .result-card .sub {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.3;
      }

      .result-card.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px var(--accent-soft);
      }

      .empty {
        color: var(--muted);
        padding: 16px;
        font-size: 13px;
      }

      .detail-body {
        padding: 10px;
        overflow: auto;
      }

      .detail-image {
        width: 100%;
        max-height: 260px;
        object-fit: contain;
        border-radius: 8px;
        background: #f1ece7;
        border: 1px solid var(--line);
      }

      .detail-title {
        margin: 10px 0 6px;
        font-size: 18px;
      }

      .detail-table {
        display: grid;
        grid-template-columns: 110px 1fr;
        gap: 8px 10px;
        font-size: 13px;
      }

      .detail-key {
        color: var(--muted);
      }

      .skeleton {
        animation: pulse 1.3s infinite ease-in-out;
        background: linear-gradient(90deg, #eee7e1 0%, #f8f2ed 50%, #eee7e1 100%);
        background-size: 200% 100%;
      }

      @keyframes pulse {
        0% {
          background-position: 0% 0%;
        }

        100% {
          background-position: 200% 0%;
        }
      }

      @media (max-width: 900px) {
        .controls-grid {
          grid-template-columns: 1fr;
        }

        .content {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="app">
      <section class="controls">
        <form id="search-form">
          <div class="controls-grid">
            <div>
              <label for="query">Search Query</label>
              <input id="query" type="text" placeholder="sunflowers, dragons, armor..." />
            </div>
            <div>
              <label for="department">Department</label>
              <select id="department">
                <option value="">All departments</option>
              </select>
            </div>
            <div>
              <label>&nbsp;</label>
              <button id="search-btn" type="submit">Search</button>
            </div>
          </div>
          <div class="flags">
            <label><input id="has-images" type="checkbox" checked /> Has images</label>
            <label><input id="title-only" type="checkbox" /> Title only</label>
          </div>
        </form>
      </section>

      <div id="status" class="status"></div>

      <section class="content">
        <article class="panel">
          <div id="results-title" class="panel-title">Results</div>
          <div id="results" class="results-list">
            <div class="empty">Run a search to explore objects.</div>
          </div>
        </article>

        <article class="panel">
          <div class="panel-title">Object Details</div>
          <div id="details" class="detail-body">
            <div class="empty">Select an object to see details.</div>
          </div>
        </article>
      </section>
    </main>

    <script>
      __APP_WITH_DEPS_RUNTIME_CODE__;
    </script>
    <script type="module">
      const state = {
        launch: {},
        results: [],
        selectedObject: null,
        selectedImageData: null,
        latestSearchToken: 0,
      };

      const queryInput = document.getElementById('query');
      const departmentSelect = document.getElementById('department');
      const hasImagesInput = document.getElementById('has-images');
      const titleOnlyInput = document.getElementById('title-only');
      const searchButton = document.getElementById('search-btn');
      const searchForm = document.getElementById('search-form');
      const statusEl = document.getElementById('status');
      const resultsTitleEl = document.getElementById('results-title');
      const resultsEl = document.getElementById('results');
      const detailsEl = document.getElementById('details');

      const runtime = globalThis.__MCP_APPS_RUNTIME__;
      if (!runtime) {
        setStatus('Could not load MCP Apps runtime in this host.', true);
        throw new Error('Failed to load @modelcontextprotocol/ext-apps runtime');
      }

      const { App, applyDocumentTheme, applyHostFonts, applyHostStyleVariables } = runtime;

      const app = new App({ name: 'met-explorer-app', version: '0.1.0' }, {});

      app.onhostcontextchanged = (contextUpdate) => {
        applyContext(contextUpdate);
      };

      app.ontoolinput = (params) => {
        applyLaunchState(params.arguments);
      };

      app.ontoolresult = (params) => {
        const initialState = getStructuredValue(params)?.initialState;
        applyLaunchState(initialState);
      };

      searchForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        await runSearch();
      });

      hasImagesInput.addEventListener('change', () => {
        if (hasImagesInput.checked && titleOnlyInput.checked) {
          titleOnlyInput.checked = false;
        }
      });

      titleOnlyInput.addEventListener('change', () => {
        if (titleOnlyInput.checked && hasImagesInput.checked) {
          hasImagesInput.checked = false;
        }
      });

      async function init() {
        try {
          await app.connect();
          applyContext(app.getHostContext());

          await loadDepartments();

          if (state.launch.q) {
            queryInput.value = state.launch.q;
            await runSearch();
          } else if (state.launch.objectId) {
            await loadObjectDetails(state.launch.objectId);
          } else {
            setStatus('Ready. Enter a query and search the collection.', false);
          }
        } catch (error) {
          setStatus(errorToMessage(error), true);
        }
      }

      function applyContext(context) {
        if (!context) {
          return;
        }

        if (context.theme) {
          applyDocumentTheme(context.theme);
        }

        if (context.styles?.variables) {
          applyHostStyleVariables(context.styles.variables);
        }

        if (context.styles?.css?.fonts) {
          applyHostFonts(context.styles.css.fonts);
        }
      }

      function applyLaunchState(rawState) {
        if (!rawState || typeof rawState !== 'object') {
          return;
        }

        const launch = rawState;
        if (typeof launch.q === 'string') {
          state.launch.q = launch.q;
          queryInput.value = launch.q;
        }

        if (typeof launch.hasImages === 'boolean') {
          state.launch.hasImages = launch.hasImages;
          hasImagesInput.checked = launch.hasImages;
        }

        if (typeof launch.title === 'boolean') {
          state.launch.title = launch.title;
          titleOnlyInput.checked = launch.title;
        }

        if (typeof launch.departmentId === 'number') {
          state.launch.departmentId = launch.departmentId;
          departmentSelect.value = String(launch.departmentId);
        }

        if (typeof launch.objectId === 'number') {
          state.launch.objectId = launch.objectId;
        }
      }

      async function loadDepartments() {
        const result = await callTool('list-departments', {});
        const departments = parseDepartments(result);

        for (const department of departments) {
          const option = document.createElement('option');
          option.value = String(department.departmentId);
          option.textContent = department.displayName;
          departmentSelect.append(option);
        }

        if (state.launch.departmentId) {
          departmentSelect.value = String(state.launch.departmentId);
        }
      }

      async function runSearch() {
        const q = queryInput.value.trim();
        if (!q) {
          setStatus('Enter a search query first.', true);
          return;
        }

        const departmentRaw = departmentSelect.value;
        const args = {
          q,
          hasImages: hasImagesInput.checked,
          title: titleOnlyInput.checked,
        };

        if (departmentRaw) {
          args.departmentId = Number(departmentRaw);
        }

        const token = ++state.latestSearchToken;
        state.results = [];
        renderResults();
        setStatus('Searching The Met collection...', false);
        setBusy(true);

        try {
          const searchResult = await callTool('search-museum-objects', args);
          const parsed = parseSearchResult(searchResult);

          resultsTitleEl.textContent =
            parsed.total > 0 ? 'Results (' + parsed.total + ' total, showing first 24)' : 'Results';

          if (!parsed.objectIDs.length) {
            state.results = [];
            renderResults();
            setStatus('No objects found for this query.', false);
            return;
          }

          const idsToLoad = parsed.objectIDs.slice(0, 24);
          setStatus('Loading object previews...', false);
          const hydrated = await hydrateObjects(idsToLoad, token);

          if (token !== state.latestSearchToken) {
            return;
          }

          state.results = hydrated;
          renderResults();
          setStatus('Loaded ' + hydrated.length + ' object previews.', false);

          if (state.launch.objectId) {
            const target = state.launch.objectId;
            state.launch.objectId = undefined;
            await loadObjectDetails(target);
          }
        } catch (error) {
          if (token !== state.latestSearchToken) {
            return;
          }
          setStatus(errorToMessage(error), true);
        } finally {
          if (token === state.latestSearchToken) {
            setBusy(false);
          }
        }
      }

      async function hydrateObjects(objectIds, token) {
        const results = [];

        await runWithConcurrency(objectIds, 4, async (objectId) => {
          if (token !== state.latestSearchToken) {
            return;
          }

          try {
            const result = await callTool('get-museum-object', {
              objectId,
              returnImage: false,
            });
            const parsedObject = parseObjectResult(result);
            if (!parsedObject) {
              return;
            }
            results.push({
              objectID: Number(parsedObject.objectID ?? objectId),
              title: stringOrFallback(parsedObject.title, 'Untitled'),
              artistDisplayName: stringOrFallback(parsedObject.artistDisplayName, 'Unknown artist'),
              department: stringOrFallback(parsedObject.department, ''),
              primaryImageSmall: stringOrFallback(parsedObject.primaryImageSmall, ''),
            });
          } catch {
            // Swallow per-object failures so one bad object does not block the whole grid.
          }
        });

        return results;
      }

      async function runWithConcurrency(items, concurrency, worker) {
        const queue = [...items];
        const workers = [];

        for (let i = 0; i < concurrency; i += 1) {
          workers.push(
            (async () => {
              while (queue.length) {
                const item = queue.shift();
                if (item === undefined) {
                  return;
                }
                await worker(item);
              }
            })(),
          );
        }

        await Promise.all(workers);
      }

      function renderResults() {
        resultsEl.innerHTML = '';

        if (!state.results.length) {
          const empty = document.createElement('div');
          empty.className = 'empty';
          empty.textContent = 'No results loaded.';
          resultsEl.append(empty);
          return;
        }

        for (const result of state.results) {
          const card = document.createElement('button');
          card.type = 'button';
          card.className = 'result-card' + (state.selectedObject?.objectID === result.objectID ? ' active' : '');
          card.addEventListener('click', () => {
            loadObjectDetails(result.objectID).catch((error) => {
              setStatus(errorToMessage(error), true);
            });
          });

          if (result.primaryImageSmall) {
            const img = document.createElement('img');
            img.src = result.primaryImageSmall;
            img.alt = result.title;
            card.append(img);
          } else {
            const placeholder = document.createElement('div');
            placeholder.className = 'skeleton';
            placeholder.style.height = '120px';
            card.append(placeholder);
          }

          const meta = document.createElement('div');
          meta.className = 'meta';

          const title = document.createElement('div');
          title.className = 'title';
          title.textContent = result.title;

          const sub = document.createElement('div');
          sub.className = 'sub';
          sub.textContent = result.artistDisplayName;

          const sub2 = document.createElement('div');
          sub2.className = 'sub';
          sub2.textContent = result.department;

          meta.append(title, sub, sub2);
          card.append(meta);
          resultsEl.append(card);
        }
      }

      async function loadObjectDetails(objectId) {
        detailsEl.innerHTML = '<div class="skeleton" style="height: 260px; border-radius: 8px;"></div>';
        setStatus('Loading object ' + objectId + '...', false);

        const result = await callTool('get-museum-object', {
          objectId,
          returnImage: true,
        });

        const objectData = parseObjectResult(result);
        state.selectedObject = objectData;
        state.selectedImageData = getImageData(result);

        renderResults();
        renderDetails();
        setStatus('Loaded object ' + objectId + '.', false);
      }

      function renderDetails() {
        detailsEl.innerHTML = '';

        if (!state.selectedObject) {
          const empty = document.createElement('div');
          empty.className = 'empty';
          empty.textContent = 'Select an object to see details.';
          detailsEl.append(empty);
          return;
        }

        const objectData = state.selectedObject;

        if (state.selectedImageData || objectData.primaryImage) {
          const image = document.createElement('img');
          image.className = 'detail-image';
          image.alt = stringOrFallback(objectData.title, 'Artwork image');
          image.src = state.selectedImageData
            ? 'data:image/jpeg;base64,' + state.selectedImageData
            : objectData.primaryImage;
          detailsEl.append(image);
        }

        const title = document.createElement('h2');
        title.className = 'detail-title';
        title.textContent = stringOrFallback(objectData.title, 'Untitled');
        detailsEl.append(title);

        const table = document.createElement('div');
        table.className = 'detail-table';

        appendDetailRow(table, 'Object ID', objectData.objectID);
        appendDetailRow(table, 'Artist', objectData.artistDisplayName);
        appendDetailRow(table, 'Artist Bio', objectData.artistDisplayBio);
        appendDetailRow(table, 'Department', objectData.department);
        appendDetailRow(table, 'Date', objectData.objectDate);
        appendDetailRow(table, 'Medium', objectData.medium);
        appendDetailRow(table, 'Dimensions', objectData.dimensions);
        appendDetailRow(table, 'Credit Line', objectData.creditLine);

        const tagText = Array.isArray(objectData.tags)
          ? objectData.tags
              .map((tag) => tag?.term)
              .filter(Boolean)
              .join(', ')
          : '';
        appendDetailRow(table, 'Tags', tagText);

        detailsEl.append(table);
      }

      function appendDetailRow(table, key, value) {
        if (!value) {
          return;
        }

        const keyEl = document.createElement('div');
        keyEl.className = 'detail-key';
        keyEl.textContent = key;

        const valueEl = document.createElement('div');
        valueEl.textContent = String(value);

        table.append(keyEl, valueEl);
      }

      async function callTool(name, args) {
        const result = await app.callServerTool({ name, arguments: args });
        if (result.isError) {
          throw new Error(extractText(result) || 'Tool call failed: ' + name);
        }
        return result;
      }

      function parseDepartments(result) {
        const structured = getStructuredValue(result);
        if (Array.isArray(structured?.departments)) {
          return structured.departments;
        }

        const text = extractText(result);
        return text
          .split('\n')
          .map((line) => {
            const match = line.match(/^Department ID:\s*(\d+),\s*Display Name:\s*(.+)$/);
            if (!match) {
              return null;
            }
            return {
              departmentId: Number(match[1]),
              displayName: match[2],
            };
          })
          .filter(Boolean);
      }

      function parseSearchResult(result) {
        const structured = getStructuredValue(result);
        if (structured && typeof structured.total === 'number' && Array.isArray(structured.objectIDs)) {
          return {
            total: structured.total,
            objectIDs: structured.objectIDs,
          };
        }

        const text = extractText(result);
        if (text.includes('No objects found')) {
          return { total: 0, objectIDs: [] };
        }

        const totalMatch = text.match(/Total objects found:\s*(\d+)/);
        const idsMatch = text.match(/Object IDs:\s*([\d,\s]+)/);
        const ids = idsMatch
          ? idsMatch[1]
              .split(',')
              .map((id) => id.trim())
              .filter(Boolean)
              .map((id) => Number(id))
              .filter((id) => Number.isFinite(id))
          : [];

        return {
          total: totalMatch ? Number(totalMatch[1]) : ids.length,
          objectIDs: ids,
        };
      }

      function parseObjectResult(result) {
        const structured = getStructuredValue(result);
        if (structured?.object && typeof structured.object === 'object') {
          return structured.object;
        }

        const text = extractText(result);
        const lines = text.split('\n');
        const parsed = {};

        for (const line of lines) {
          const dividerIndex = line.indexOf(':');
          if (dividerIndex <= 0) {
            continue;
          }

          const rawKey = line.slice(0, dividerIndex).trim();
          const value = line.slice(dividerIndex + 1).trim();
          if (!value) {
            continue;
          }

          switch (rawKey) {
            case 'Title':
              parsed.title = value;
              break;
            case 'Artist':
              parsed.artistDisplayName = value;
              break;
            case 'Artist Bio':
              parsed.artistDisplayBio = value;
              break;
            case 'Department':
              parsed.department = value;
              break;
            case 'Credit Line':
              parsed.creditLine = value;
              break;
            case 'Medium':
              parsed.medium = value;
              break;
            case 'Dimensions':
              parsed.dimensions = value;
              break;
            case 'Primary Image URL':
              parsed.primaryImage = value;
              break;
            case 'Tags':
              parsed.tags = value
                .split(',')
                .map((term) => ({ term: term.trim() }))
                .filter((tag) => tag.term);
              break;
            default:
              break;
          }
        }

        return parsed;
      }

      function extractText(result) {
        if (!Array.isArray(result?.content)) {
          return '';
        }

        return result.content
          .filter((block) => block.type === 'text' && typeof block.text === 'string')
          .map((block) => block.text)
          .join('\n')
          .trim();
      }

      function getImageData(result) {
        if (!Array.isArray(result?.content)) {
          return null;
        }

        const block = result.content.find((item) => item.type === 'image' && typeof item.data === 'string');
        return block ? block.data : null;
      }

      function getStructuredValue(result) {
        const value = result?.structuredContent;
        if (value && typeof value === 'object') {
          return value;
        }
        return null;
      }

      function setBusy(isBusy) {
        queryInput.disabled = isBusy;
        departmentSelect.disabled = isBusy;
        hasImagesInput.disabled = isBusy;
        titleOnlyInput.disabled = isBusy;
        searchButton.disabled = isBusy;
      }

      function setStatus(message, isError) {
        statusEl.textContent = message;
        statusEl.className = isError ? 'status error' : 'status';
      }

      function errorToMessage(error) {
        if (error instanceof Error) {
          return error.message;
        }
        return String(error);
      }

      function stringOrFallback(value, fallback) {
        if (typeof value === 'string' && value.trim()) {
          return value;
        }
        return fallback;
      }

      init();
    </script>
  </body>
</html>
